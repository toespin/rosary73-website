<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Upload Prayer Recordings - Rosary73</title>
  <meta name="description" content="Upload your prayer recordings to participate in community rosaries">
  <link rel="icon" type="image/png" href="images/R73logo.png">
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
      min-height: 100vh;
      color: #ffffff;
    }
    
    .header {
      padding: 20px;
      text-align: center;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      position: sticky;
      top: 0;
      background: rgba(26, 26, 46, 0.95);
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    
    .logo-link {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      text-decoration: none;
    }
    
    .logo { width: 40px; height: 40px; }
    .logo-text { color: #d4af37; font-size: 1.3rem; font-weight: 600; }
    
    .main {
      max-width: 800px;
      margin: 0 auto;
      padding: 30px 20px;
    }
    
    .page-title {
      text-align: center;
      margin-bottom: 10px;
      font-size: 1.8rem;
      color: #d4af37;
    }
    
    .page-subtitle {
      text-align: center;
      color: rgba(255,255,255,0.7);
      margin-bottom: 30px;
    }
    
    /* Login Gate */
    .login-gate {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      max-width: 400px;
      margin: 50px auto;
    }
    
    .login-gate h2 {
      color: #d4af37;
      margin-bottom: 15px;
    }
    
    .login-gate p {
      color: rgba(255,255,255,0.7);
      margin-bottom: 20px;
    }
    
    .login-form {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .login-form input {
      padding: 14px 16px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.05);
      color: #fff;
      font-size: 1rem;
    }
    
    .login-form input::placeholder {
      color: rgba(255,255,255,0.4);
    }
    
    /* Instructions Card */
    .instructions-card {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 25px;
      margin-bottom: 30px;
    }
    
    .instructions-card h3 {
      color: #d4af37;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .instructions-card ul {
      list-style: none;
      color: rgba(255,255,255,0.8);
    }
    
    .instructions-card li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
    }
    
    .instructions-card li::before {
      content: "‚úì";
      position: absolute;
      left: 0;
      color: #4ade80;
    }
    
    .language-note {
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    
    .language-note .icon { font-size: 1.5rem; }
    
    .language-note p {
      color: rgba(255,255,255,0.9);
      font-size: 0.95rem;
    }
    
    /* Formats Info */
    .formats-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    
    .format-badge {
      background: rgba(255,255,255,0.1);
      padding: 8px 12px;
      border-radius: 8px;
      text-align: center;
      font-size: 0.85rem;
    }
    
    .format-badge strong {
      color: #d4af37;
    }
    
    /* Progress Overview */
    .progress-overview {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 30px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    .progress-text {
      font-size: 1.1rem;
    }
    
    .progress-text span {
      color: #d4af37;
      font-weight: 600;
    }
    
    .progress-bar-container {
      flex: 1;
      min-width: 200px;
      max-width: 300px;
      height: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #d4af37, #f0d875);
      border-radius: 5px;
      transition: width 0.3s ease;
    }
    
    /* Prayer Cards */
    .prayer-card {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 15px;
      transition: all 0.3s ease;
    }
    
    .prayer-card:hover {
      border-color: rgba(212, 175, 55, 0.3);
    }
    
    .prayer-card.uploaded {
      border-color: rgba(74, 222, 128, 0.3);
      background: rgba(74, 222, 128, 0.05);
    }
    
    .prayer-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 15px;
    }
    
    .prayer-info h4 {
      color: #ffffff;
      font-size: 1.1rem;
      margin-bottom: 5px;
    }
    
    .prayer-requirements {
      color: rgba(255,255,255,0.6);
      font-size: 0.85rem;
    }
    
    .prayer-status {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    
    .status-pending {
      background: rgba(255,255,255,0.1);
      color: rgba(255,255,255,0.6);
    }
    
    .status-uploaded {
      background: rgba(74, 222, 128, 0.2);
      color: #4ade80;
    }
    
    .status-error {
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
    }
    
    /* Upload Area */
    .upload-area {
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 30px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .upload-area:hover {
      border-color: #d4af37;
      background: rgba(212, 175, 55, 0.05);
    }
    
    .upload-area.dragover {
      border-color: #d4af37;
      background: rgba(212, 175, 55, 0.1);
    }
    
    .upload-icon {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }
    
    .upload-text {
      color: rgba(255,255,255,0.7);
      margin-bottom: 5px;
    }
    
    .upload-hint {
      color: rgba(255,255,255,0.4);
      font-size: 0.85rem;
    }
    
    .file-input {
      display: none;
    }
    
    /* Audio Preview */
    .audio-preview {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
    }
    
    .audio-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .file-name {
      color: #d4af37;
      font-weight: 500;
      word-break: break-all;
    }
    
    .remove-file {
      background: rgba(239, 68, 68, 0.2);
      border: none;
      color: #f87171;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    
    .audio-player {
      width: 100%;
      margin: 10px 0;
    }
    
    /* Audio Analysis */
    .audio-analysis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    
    .analysis-item {
      background: rgba(255,255,255,0.05);
      padding: 10px;
      border-radius: 8px;
      text-align: center;
    }
    
    .analysis-label {
      font-size: 0.75rem;
      color: rgba(255,255,255,0.5);
      margin-bottom: 3px;
    }
    
    .analysis-value {
      font-weight: 600;
      font-size: 0.95rem;
    }
    
    .analysis-value.good { color: #4ade80; }
    .analysis-value.warning { color: #fbbf24; }
    .analysis-value.error { color: #f87171; }
    
    /* Warnings */
    .warning-box {
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-top: 10px;
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    
    .warning-box.error {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.3);
    }
    
    .warning-icon { font-size: 1.2rem; }
    
    .warning-text {
      color: rgba(255,255,255,0.9);
      font-size: 0.9rem;
    }
    
    /* Trim Controls */
    .trim-controls {
      margin-top: 15px;
      padding: 15px;
      background: rgba(212, 175, 55, 0.1);
      border-radius: 10px;
    }
    
    .trim-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .trim-header h5 {
      color: #d4af37;
      font-size: 0.9rem;
    }
    
    .trim-toggle {
      background: rgba(255,255,255,0.1);
      border: none;
      color: #fff;
      padding: 5px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .trim-toggle.active {
      background: #d4af37;
      color: #1a1a2e;
    }
    
    .trim-sliders {
      display: none;
    }
    
    .trim-sliders.visible {
      display: block;
    }
    
    .trim-slider-group {
      margin-bottom: 10px;
    }
    
    .trim-slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      margin-bottom: 5px;
      color: rgba(255,255,255,0.7);
    }
    
    .trim-slider {
      width: 100%;
      accent-color: #d4af37;
    }
    
    .trim-preview-btn {
      width: 100%;
      margin-top: 10px;
    }
    
    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      border: none;
      text-decoration: none;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #d4af37, #b8860b);
      color: #1a1a2e;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(212, 175, 55, 0.3);
    }
    
    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-secondary {
      background: rgba(255,255,255,0.1);
      color: #ffffff;
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }
    
    .btn-small {
      padding: 8px 16px;
      font-size: 0.9rem;
    }
    
    /* Upload Button */
    .upload-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .upload-btn {
      flex: 1;
    }
    
    /* Waveform */
    .waveform-container {
      height: 60px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      margin: 10px 0;
      position: relative;
      overflow: hidden;
    }
    
    .waveform-canvas {
      width: 100%;
      height: 100%;
    }
    
    .waveform-trim-overlay {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(212, 175, 55, 0.2);
      pointer-events: none;
    }
    
    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }
    
    .toast {
      background: rgba(30, 30, 50, 0.95);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 15px 20px;
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      animation: slideIn 0.3s ease;
      max-width: 350px;
    }
    
    .toast.success { border-color: rgba(74, 222, 128, 0.3); }
    .toast.error { border-color: rgba(239, 68, 68, 0.3); }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    /* Loading Spinner */
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #d4af37;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Footer */
    .footer {
      text-align: center;
      padding: 30px 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 50px;
    }
    
    .footer p {
      color: rgba(255,255,255,0.4);
      font-size: 0.85rem;
    }
    
    .footer a {
      color: #d4af37;
      text-decoration: none;
    }
    
    /* Responsive */
    @media (max-width: 600px) {
      .prayer-header {
        flex-direction: column;
        gap: 10px;
      }
      
      .progress-overview {
        flex-direction: column;
        text-align: center;
      }
      
      .progress-bar-container {
        width: 100%;
        max-width: none;
      }
    }
    
    /* Hidden */
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <header class="header">
    <a href="index.html" class="logo-link">
      <img src="images/R73logo.png" alt="Rosary73" class="logo">
      <span class="logo-text">Rosary73</span>
    </a>
  </header>

  <main class="main">
    <h1 class="page-title">üìø Upload Prayer Recordings</h1>
    <p class="page-subtitle">Record your prayers offline and upload them here</p>

    <!-- Login Gate -->
    <div id="login-gate" class="login-gate">
      <h2>üîê Sign In Required</h2>
      <p>Please sign in to upload your prayer recordings</p>
      
      <form class="login-form" id="login-form">
        <input type="text" id="login-username" placeholder="Username" required>
        <input type="password" id="login-password" placeholder="Password" required>
        <button type="submit" class="btn btn-primary">Sign In</button>
        <p style="color: rgba(255,255,255,0.5); font-size: 0.85rem; margin-top: 10px;">
          Don't have an account? <a href="signup.html" style="color: #d4af37;">Sign up here</a>
        </p>
      </form>
      
      <div id="login-error" class="warning-box error hidden" style="margin-top: 15px;">
        <span class="warning-icon">‚ùå</span>
        <span class="warning-text" id="login-error-text"></span>
      </div>
    </div>

    <!-- Main Content (hidden until logged in) -->
    <div id="main-content" class="hidden">
      <!-- User Info -->
      <div style="text-align: right; margin-bottom: 20px;">
        <span style="color: rgba(255,255,255,0.6);">Logged in as </span>
        <span id="user-display" style="color: #d4af37; font-weight: 600;"></span>
        <button id="logout-btn" class="btn btn-secondary btn-small" style="margin-left: 10px;">Logout</button>
      </div>

      <!-- Instructions -->
      <div class="instructions-card">
        <h3>üìã How to Record Your Prayers</h3>
        <ul>
          <li><strong>iPhone:</strong> Use Voice Memos app ‚Üí Record ‚Üí Share ‚Üí Save to Files</li>
          <li><strong>Android:</strong> Use Voice Recorder app ‚Üí Record ‚Üí Save to device</li>
          <li><strong>Mac:</strong> QuickTime Player ‚Üí File ‚Üí New Audio Recording</li>
          <li><strong>Windows:</strong> Voice Recorder app or Audacity (free)</li>
          <li>Find a <strong>quiet place</strong> with minimal background noise</li>
          <li>Hold your device <strong>6-12 inches</strong> from your mouth</li>
          <li>Speak <strong>clearly</strong> at a normal, reverent pace</li>
          <li>Listen back and <strong>re-record</strong> if needed before uploading</li>
        </ul>
        
        <div class="language-note">
          <span class="icon">üåç</span>
          <p><strong>Record in your own language!</strong> Rosary73 welcomes prayers in all languages. Whether you pray in English, Filipino, Spanish, Latin, or any other language, your recording will contribute to our global rosary community.</p>
        </div>
        
        <div class="formats-info">
          <div class="format-badge"><strong>M4A</strong> ‚úì Preferred</div>
          <div class="format-badge"><strong>MP3</strong> ‚úì Accepted</div>
          <div class="format-badge"><strong>WAV</strong> ‚úì Accepted</div>
          <div class="format-badge"><strong>WebM</strong> ‚úì Accepted</div>
          <div class="format-badge"><strong>Max size:</strong> 10MB</div>
        </div>
      </div>

      <!-- Progress Overview -->
      <div class="progress-overview">
        <div class="progress-text">
          Progress: <span id="progress-count">0</span> of 7 prayers uploaded
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
        </div>
      </div>

      <!-- Prayer Cards Container -->
      <div id="prayer-cards"></div>

    </div>
  </main>

  <footer class="footer">
    <p>Need help? <a href="contact.html">Contact Support</a> | <a href="index.html">Back to Home</a></p>
  </footer>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-storage-compat.js"></script>

  <script>
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBBzm-LuWZwyOCMqYzxodpqLNn4Eg3wNDk",
      authDomain: "rosary--interact-app.firebaseapp.com",
      projectId: "rosary--interact-app",
      storageBucket: "rosary--interact-app.firebasestorage.app",
      messagingSenderId: "174985016192",
      appId: "1:174985016192:web:134b684d6f0ba731510765"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();

    // Prayer Configuration
    const PRAYERS = [
      { id: 'creed', name: 'The Creed (Apostles\' Creed)', minDuration: 20, maxDuration: 55 },
      { id: 'ourFather', name: 'Our Father', minDuration: 12, maxDuration: 30 },
      { id: 'hailMary', name: 'Hail Mary', minDuration: 10, maxDuration: 27 },
      { id: 'gloryBe', name: 'Glory Be', minDuration: 5, maxDuration: 17 },
      { id: 'fatimaPrayer', name: 'Fatima Prayer (O My Jesus)', minDuration: 5, maxDuration: 20 },
      { id: 'hailHolyQueen', name: 'Hail Holy Queen', minDuration: 12, maxDuration: 41 },
      { id: 'finalPrayer', name: 'Final Prayer (Let Us Pray)', minDuration: 10, maxDuration: 35 }
    ];

    const ACCEPTED_FORMATS = ['audio/mp4', 'audio/x-m4a', 'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/webm', 'audio/ogg'];
    const ACCEPTED_EXTENSIONS = ['.m4a', '.mp3', '.wav', '.webm', '.ogg', '.mp4'];
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

    // State
    let currentUser = null;
    let userData = null;
    let prayerStates = {};

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initializeAuth();
      setupLoginForm();
    });

    // Auth State Listener
    function initializeAuth() {
      auth.onAuthStateChanged(async (user) => {
        if (user) {
          currentUser = user;
          await loadUserData();
          showMainContent();
        } else {
          currentUser = null;
          userData = null;
          showLoginGate();
        }
      });
    }

    // Load User Data
    async function loadUserData() {
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (userDoc.exists) {
          userData = userDoc.data();
          document.getElementById('user-display').textContent = userData.username || userData.email;
        }
      } catch (error) {
        console.error('Error loading user data:', error);
        showToast('Error loading user data', 'error');
      }
    }

    // Setup Login Form
    function setupLoginForm() {
      document.getElementById('login-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const username = document.getElementById('login-username').value.trim();
        const password = document.getElementById('login-password').value;
        
        const submitBtn = e.target.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="spinner"></span> Signing in...';
        
        try {
          // Get email from username
          const response = await fetch('https://us-central1-rosary--interact-app.cloudfunctions.net/verifyWebUser', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username })
          });
          
          const result = await response.json();
          
          if (!result.valid) {
            throw new Error(result.error || 'Username not found');
          }
          
          // Get email from Firestore using the userId
          const userDoc = await db.collection('users').doc(result.userId).get();
          if (!userDoc.exists) {
            throw new Error('User not found');
          }
          
          const email = userDoc.data().email;
          
          // Sign in with Firebase Auth
          await auth.signInWithEmailAndPassword(email, password);
          
          showToast('Signed in successfully!', 'success');
          
        } catch (error) {
          console.error('Login error:', error);
          document.getElementById('login-error').classList.remove('hidden');
          document.getElementById('login-error-text').textContent = error.message || 'Login failed';
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Sign In';
        }
      });
      
      // Logout button
      document.getElementById('logout-btn').addEventListener('click', async () => {
        await auth.signOut();
        showToast('Logged out', 'success');
      });
    }

    // Show/Hide Views
    function showLoginGate() {
      document.getElementById('login-gate').classList.remove('hidden');
      document.getElementById('main-content').classList.add('hidden');
    }

    function showMainContent() {
      document.getElementById('login-gate').classList.add('hidden');
      document.getElementById('main-content').classList.remove('hidden');
      renderPrayerCards();
      updateProgress();
    }

    // Render Prayer Cards
    function renderPrayerCards() {
      const container = document.getElementById('prayer-cards');
      container.innerHTML = '';
      
      PRAYERS.forEach((prayer, index) => {
        const existingRecording = userData?.recordings?.[prayer.id];
        prayerStates[prayer.id] = {
          file: null,
          audioData: null,
          analysis: null,
          trimStart: 0,
          trimEnd: 0,
          uploaded: !!existingRecording
        };
        
        const card = document.createElement('div');
        card.className = `prayer-card ${existingRecording ? 'uploaded' : ''}`;
        card.id = `prayer-card-${prayer.id}`;
        
        card.innerHTML = `
          <div class="prayer-header">
            <div class="prayer-info">
              <h4>${index + 1}. ${prayer.name}</h4>
              <div class="prayer-requirements">
                Duration: ${prayer.minDuration}-${prayer.maxDuration} seconds
              </div>
            </div>
            <span class="prayer-status ${existingRecording ? 'status-uploaded' : 'status-pending'}" id="status-${prayer.id}">
              ${existingRecording ? '‚úì Uploaded' : '‚óã Not uploaded'}
            </span>
          </div>
          
          <div class="upload-area" id="upload-area-${prayer.id}" onclick="triggerFileInput('${prayer.id}')">
            <div class="upload-icon">üìÅ</div>
            <div class="upload-text">${existingRecording ? 'Click to replace recording' : 'Click to select file or drag & drop'}</div>
            <div class="upload-hint">M4A, MP3, WAV, WebM ‚Ä¢ Max 10MB</div>
          </div>
          <input type="file" class="file-input" id="file-input-${prayer.id}" accept="audio/*" onchange="handleFileSelect('${prayer.id}', event)">
          
          <div class="audio-preview hidden" id="preview-${prayer.id}"></div>
        `;
        
        container.appendChild(card);
        
        // Setup drag & drop
        setupDragDrop(prayer.id);
      });
    }

    // File Input Trigger
    function triggerFileInput(prayerId) {
      document.getElementById(`file-input-${prayerId}`).click();
    }

    // Setup Drag & Drop
    function setupDragDrop(prayerId) {
      const area = document.getElementById(`upload-area-${prayerId}`);
      
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        area.addEventListener(eventName, (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });
      
      ['dragenter', 'dragover'].forEach(eventName => {
        area.addEventListener(eventName, () => area.classList.add('dragover'));
      });
      
      ['dragleave', 'drop'].forEach(eventName => {
        area.addEventListener(eventName, () => area.classList.remove('dragover'));
      });
      
      area.addEventListener('drop', (e) => {
        const file = e.dataTransfer.files[0];
        if (file) processFile(prayerId, file);
      });
    }

    // Handle File Select
    function handleFileSelect(prayerId, event) {
      const file = event.target.files[0];
      if (file) processFile(prayerId, file);
    }

    // Process File
    async function processFile(prayerId, file) {
      const prayer = PRAYERS.find(p => p.id === prayerId);
      const preview = document.getElementById(`preview-${prayerId}`);
      
      // Validate file type
      const ext = '.' + file.name.split('.').pop().toLowerCase();
      if (!ACCEPTED_EXTENSIONS.includes(ext)) {
        showToast(`Invalid file format. Accepted: ${ACCEPTED_EXTENSIONS.join(', ')}`, 'error');
        return;
      }
      
      // Validate file size
      if (file.size > MAX_FILE_SIZE) {
        showToast('File too large. Maximum size is 10MB.', 'error');
        return;
      }
      
      // Show loading
      preview.classList.remove('hidden');
      preview.innerHTML = `
        <div style="text-align: center; padding: 20px;">
          <div class="spinner" style="margin: 0 auto 10px;"></div>
          <div>Analyzing audio...</div>
        </div>
      `;
      
      try {
        // Analyze audio
        const analysis = await analyzeAudio(file, prayer);
        
        // Store state
        prayerStates[prayerId].file = file;
        prayerStates[prayerId].analysis = analysis;
        prayerStates[prayerId].trimStart = analysis.silenceStart || 0;
        prayerStates[prayerId].trimEnd = analysis.silenceEnd || analysis.duration;
        
        // Render preview
        renderAudioPreview(prayerId, file, analysis, prayer);
        
      } catch (error) {
        console.error('Error analyzing audio:', error);
        preview.innerHTML = `
          <div class="warning-box error">
            <span class="warning-icon">‚ùå</span>
            <span class="warning-text">Error analyzing audio: ${error.message}</span>
          </div>
        `;
      }
    }

    // Analyze Audio
    async function analyzeAudio(file, prayer) {
      return new Promise((resolve, reject) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const reader = new FileReader();
        
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const duration = audioBuffer.duration;
            const channelData = audioBuffer.getChannelData(0);
            
            // Analyze volume levels
            let sumSquares = 0;
            let maxAmplitude = 0;
            const sampleRate = audioBuffer.sampleRate;
            
            for (let i = 0; i < channelData.length; i++) {
              const sample = Math.abs(channelData[i]);
              sumSquares += sample * sample;
              if (sample > maxAmplitude) maxAmplitude = sample;
            }
            
            const rms = Math.sqrt(sumSquares / channelData.length);
            const avgDb = 20 * Math.log10(rms + 0.0001);
            const peakDb = 20 * Math.log10(maxAmplitude + 0.0001);
            
            // Detect silence at start and end
            const silenceThreshold = 0.02;
            let silenceStart = 0;
            let silenceEnd = duration;
            
            // Find silence at start
            for (let i = 0; i < channelData.length; i++) {
              if (Math.abs(channelData[i]) > silenceThreshold) {
                silenceStart = Math.max(0, (i / sampleRate) - 0.1); // 100ms buffer
                break;
              }
            }
            
            // Find silence at end
            for (let i = channelData.length - 1; i >= 0; i--) {
              if (Math.abs(channelData[i]) > silenceThreshold) {
                silenceEnd = Math.min(duration, (i / sampleRate) + 0.1); // 100ms buffer
                break;
              }
            }
            
            // Detect noise (check for consistent low-level noise)
            const windowSize = Math.floor(sampleRate * 0.1); // 100ms windows
            let noiseWindows = 0;
            let totalWindows = 0;
            
            for (let i = 0; i < channelData.length; i += windowSize) {
              let windowMax = 0;
              for (let j = i; j < Math.min(i + windowSize, channelData.length); j++) {
                windowMax = Math.max(windowMax, Math.abs(channelData[j]));
              }
              totalWindows++;
              if (windowMax > 0.01 && windowMax < 0.1) {
                noiseWindows++;
              }
            }
            
            const noiseRatio = noiseWindows / totalWindows;
            
            // Generate waveform data for visualization
            const waveformData = [];
            const samplesPerPixel = Math.floor(channelData.length / 200);
            for (let i = 0; i < 200; i++) {
              let max = 0;
              for (let j = 0; j < samplesPerPixel; j++) {
                const idx = i * samplesPerPixel + j;
                if (idx < channelData.length) {
                  max = Math.max(max, Math.abs(channelData[idx]));
                }
              }
              waveformData.push(max);
            }
            
            resolve({
              duration,
              avgDb,
              peakDb,
              silenceStart,
              silenceEnd,
              noiseRatio,
              waveformData,
              durationValid: duration >= prayer.minDuration && duration <= prayer.maxDuration,
              trimmedDuration: silenceEnd - silenceStart,
              hasSilenceToTrim: silenceStart > 0.5 || (duration - silenceEnd) > 0.5
            });
            
          } catch (error) {
            reject(error);
          }
        };
        
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Render Audio Preview
    function renderAudioPreview(prayerId, file, analysis, prayer) {
      const preview = document.getElementById(`preview-${prayerId}`);
      const state = prayerStates[prayerId];
      
      // Duration check
      let durationStatus = 'good';
      let durationMessage = '';
      if (analysis.duration < prayer.minDuration) {
        durationStatus = 'error';
        durationMessage = `Too short! Minimum ${prayer.minDuration}s required.`;
      } else if (analysis.duration > prayer.maxDuration) {
        durationStatus = 'warning';
        durationMessage = `Longer than expected. Consider trimming to under ${prayer.maxDuration}s.`;
      }
      
      // Volume check
      let volumeStatus = 'good';
      let volumeMessage = '';
      if (analysis.avgDb < -35) {
        volumeStatus = 'error';
        volumeMessage = 'Recording is too quiet. Please record closer to the microphone.';
      } else if (analysis.avgDb < -25) {
        volumeStatus = 'warning';
        volumeMessage = 'Recording volume is low. Consider recording louder.';
      } else if (analysis.peakDb > -3) {
        volumeStatus = 'warning';
        volumeMessage = 'Some parts may be distorted. Consider recording at lower volume.';
      }
      
      // Noise check
      let noiseStatus = 'good';
      let noiseMessage = '';
      if (analysis.noiseRatio > 0.4) {
        noiseStatus = 'warning';
        noiseMessage = 'Background noise detected. Consider recording in a quieter environment.';
      }
      
      const canUpload = analysis.duration >= prayer.minDuration;
      
      preview.innerHTML = `
        <div class="audio-preview-header">
          <span class="file-name">üìÑ ${file.name}</span>
          <button class="remove-file" onclick="removeFile('${prayerId}')">‚úï Remove</button>
        </div>
        
        <div class="waveform-container">
          <canvas class="waveform-canvas" id="waveform-${prayerId}"></canvas>
          <div class="waveform-trim-overlay" id="trim-overlay-${prayerId}"></div>
        </div>
        
        <audio controls class="audio-player" id="audio-player-${prayerId}">
          <source src="${URL.createObjectURL(file)}" type="${file.type}">
        </audio>
        
        <div class="audio-analysis">
          <div class="analysis-item">
            <div class="analysis-label">Duration</div>
            <div class="analysis-value ${durationStatus}">${analysis.duration.toFixed(1)}s</div>
          </div>
          <div class="analysis-item">
            <div class="analysis-label">Required</div>
            <div class="analysis-value">${prayer.minDuration}-${prayer.maxDuration}s</div>
          </div>
          <div class="analysis-item">
            <div class="analysis-label">Volume</div>
            <div class="analysis-value ${volumeStatus}">${analysis.avgDb > -25 ? 'Good' : analysis.avgDb > -35 ? 'Low' : 'Too Quiet'}</div>
          </div>
          <div class="analysis-item">
            <div class="analysis-label">Quality</div>
            <div class="analysis-value ${noiseStatus}">${analysis.noiseRatio < 0.3 ? 'Good' : 'Noisy'}</div>
          </div>
        </div>
        
        ${durationMessage ? `<div class="warning-box ${durationStatus === 'error' ? 'error' : ''}"><span class="warning-icon">${durationStatus === 'error' ? '‚ùå' : '‚ö†Ô∏è'}</span><span class="warning-text">${durationMessage}</span></div>` : ''}
        ${volumeMessage ? `<div class="warning-box ${volumeStatus === 'error' ? 'error' : ''}"><span class="warning-icon">${volumeStatus === 'error' ? '‚ùå' : '‚ö†Ô∏è'}</span><span class="warning-text">${volumeMessage}</span></div>` : ''}
        ${noiseMessage ? `<div class="warning-box"><span class="warning-icon">‚ö†Ô∏è</span><span class="warning-text">${noiseMessage}</span></div>` : ''}
        
        ${analysis.hasSilenceToTrim ? `
        <div class="trim-controls">
          <div class="trim-header">
            <h5>‚úÇÔ∏è Trim Silence</h5>
            <button class="trim-toggle" id="trim-toggle-${prayerId}" onclick="toggleTrim('${prayerId}')">
              Auto-trim: OFF
            </button>
          </div>
          <div class="trim-sliders" id="trim-sliders-${prayerId}">
            <p style="font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-bottom: 10px;">
              Detected ${analysis.silenceStart.toFixed(1)}s silence at start, ${(analysis.duration - analysis.silenceEnd).toFixed(1)}s at end
            </p>
            <div class="trim-slider-group">
              <div class="trim-slider-label">
                <span>Start trim</span>
                <span id="trim-start-value-${prayerId}">${analysis.silenceStart.toFixed(1)}s</span>
              </div>
              <input type="range" class="trim-slider" id="trim-start-${prayerId}" 
                min="0" max="${analysis.duration}" step="0.1" value="${analysis.silenceStart}"
                onchange="updateTrim('${prayerId}')">
            </div>
            <div class="trim-slider-group">
              <div class="trim-slider-label">
                <span>End trim</span>
                <span id="trim-end-value-${prayerId}">${analysis.silenceEnd.toFixed(1)}s</span>
              </div>
              <input type="range" class="trim-slider" id="trim-end-${prayerId}" 
                min="0" max="${analysis.duration}" step="0.1" value="${analysis.silenceEnd}"
                onchange="updateTrim('${prayerId}')">
            </div>
            <p style="font-size: 0.85rem; color: #d4af37; margin-top: 5px;">
              Trimmed duration: <span id="trimmed-duration-${prayerId}">${(analysis.silenceEnd - analysis.silenceStart).toFixed(1)}</span>s
            </p>
          </div>
        </div>
        ` : ''}
        
        <div class="upload-actions">
          <button class="btn btn-primary upload-btn" onclick="uploadPrayer('${prayerId}')" ${!canUpload ? 'disabled' : ''}>
            üì§ Upload Recording
          </button>
        </div>
      `;
      
      // Draw waveform
      drawWaveform(prayerId, analysis.waveformData);
    }

    // Draw Waveform
    function drawWaveform(prayerId, waveformData) {
      const canvas = document.getElementById(`waveform-${prayerId}`);
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      
      const width = rect.width;
      const height = rect.height;
      const barWidth = width / waveformData.length;
      const centerY = height / 2;
      
      ctx.fillStyle = '#d4af37';
      
      waveformData.forEach((value, i) => {
        const barHeight = value * height * 0.8;
        ctx.fillRect(
          i * barWidth,
          centerY - barHeight / 2,
          barWidth - 1,
          barHeight
        );
      });
    }

    // Toggle Trim
    function toggleTrim(prayerId) {
      const toggle = document.getElementById(`trim-toggle-${prayerId}`);
      const sliders = document.getElementById(`trim-sliders-${prayerId}`);
      const state = prayerStates[prayerId];
      
      state.trimEnabled = !state.trimEnabled;
      
      if (state.trimEnabled) {
        toggle.textContent = 'Auto-trim: ON';
        toggle.classList.add('active');
        sliders.classList.add('visible');
      } else {
        toggle.textContent = 'Auto-trim: OFF';
        toggle.classList.remove('active');
        sliders.classList.remove('visible');
        // Reset trim values
        state.trimStart = 0;
        state.trimEnd = state.analysis.duration;
      }
    }

    // Update Trim
    function updateTrim(prayerId) {
      const state = prayerStates[prayerId];
      const startSlider = document.getElementById(`trim-start-${prayerId}`);
      const endSlider = document.getElementById(`trim-end-${prayerId}`);
      
      state.trimStart = parseFloat(startSlider.value);
      state.trimEnd = parseFloat(endSlider.value);
      
      document.getElementById(`trim-start-value-${prayerId}`).textContent = state.trimStart.toFixed(1) + 's';
      document.getElementById(`trim-end-value-${prayerId}`).textContent = state.trimEnd.toFixed(1) + 's';
      document.getElementById(`trimmed-duration-${prayerId}`).textContent = (state.trimEnd - state.trimStart).toFixed(1);
      
      // Update trim overlay on waveform
      const overlay = document.getElementById(`trim-overlay-${prayerId}`);
      const duration = state.analysis.duration;
      overlay.style.left = (state.trimStart / duration * 100) + '%';
      overlay.style.width = ((state.trimEnd - state.trimStart) / duration * 100) + '%';
    }

    // Remove File
    function removeFile(prayerId) {
      const state = prayerStates[prayerId];
      state.file = null;
      state.analysis = null;
      
      document.getElementById(`preview-${prayerId}`).classList.add('hidden');
      document.getElementById(`preview-${prayerId}`).innerHTML = '';
      document.getElementById(`file-input-${prayerId}`).value = '';
    }

    // Upload Prayer
    async function uploadPrayer(prayerId) {
      const state = prayerStates[prayerId];
      const prayer = PRAYERS.find(p => p.id === prayerId);
      
      if (!state.file) {
        showToast('No file selected', 'error');
        return;
      }
      
      const preview = document.getElementById(`preview-${prayerId}`);
      const uploadBtn = preview.querySelector('.upload-btn');
      
      uploadBtn.disabled = true;
      uploadBtn.innerHTML = '<span class="spinner"></span> Uploading...';
      
      try {
        let fileToUpload = state.file;
        
        // If trimming is enabled, we need to process the audio
        // For now, we'll upload the full file and note: server-side trimming can be added later
        // Or we can use Web Audio API to trim client-side
        
        if (state.trimEnabled && (state.trimStart > 0 || state.trimEnd < state.analysis.duration)) {
          // Trim audio using Web Audio API
          fileToUpload = await trimAudio(state.file, state.trimStart, state.trimEnd);
        }
        
        // Upload to Firebase Storage
        const extension = state.file.name.split('.').pop().toLowerCase();
        const storagePath = `users/${currentUser.uid}/prayers/${prayerId}.${extension === 'webm' ? 'm4a' : extension}`;
        const storageRef = storage.ref(storagePath);
        
        await storageRef.put(fileToUpload);
        const downloadUrl = await storageRef.getDownloadURL();
        
        // Update Firestore
        await db.collection('users').doc(currentUser.uid).update({
          [`recordings.${prayerId}`]: downloadUrl
        });
        
        // Update local state
        state.uploaded = true;
        userData.recordings = userData.recordings || {};
        userData.recordings[prayerId] = downloadUrl;
        
        // Update UI
        const card = document.getElementById(`prayer-card-${prayerId}`);
        card.classList.add('uploaded');
        document.getElementById(`status-${prayerId}`).textContent = '‚úì Uploaded';
        document.getElementById(`status-${prayerId}`).className = 'prayer-status status-uploaded';
        
        updateProgress();
        showToast(`${prayer.name} uploaded successfully!`, 'success');
        
        // Clear preview
        preview.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #4ade80;">
            ‚úÖ Recording uploaded successfully!
            <br><small style="color: rgba(255,255,255,0.6);">Click the upload area above to replace this recording</small>
          </div>
        `;
        
      } catch (error) {
        console.error('Upload error:', error);
        showToast('Upload failed: ' + error.message, 'error');
        uploadBtn.disabled = false;
        uploadBtn.innerHTML = 'üì§ Upload Recording';
      }
    }

    // Trim Audio (client-side)
    async function trimAudio(file, startTime, endTime) {
      return new Promise((resolve, reject) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const reader = new FileReader();
        
        reader.onload = async (e) => {
          try {
            const arrayBuffer = e.target.result;
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const sampleRate = audioBuffer.sampleRate;
            const startSample = Math.floor(startTime * sampleRate);
            const endSample = Math.floor(endTime * sampleRate);
            const newLength = endSample - startSample;
            
            const newBuffer = audioContext.createBuffer(
              audioBuffer.numberOfChannels,
              newLength,
              sampleRate
            );
            
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
              const oldData = audioBuffer.getChannelData(channel);
              const newData = newBuffer.getChannelData(channel);
              for (let i = 0; i < newLength; i++) {
                newData[i] = oldData[startSample + i];
              }
            }
            
            // Convert to WAV blob (most compatible)
            const wavBlob = audioBufferToWav(newBuffer);
            resolve(wavBlob);
            
          } catch (error) {
            reject(error);
          }
        };
        
        reader.onerror = () => reject(new Error('Failed to read file for trimming'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Convert AudioBuffer to WAV Blob
    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;
      
      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;
      
      const dataLength = buffer.length * blockAlign;
      const bufferLength = 44 + dataLength;
      
      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);
      
      // WAV header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, bufferLength - 8, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);
      
      // Write audio data
      const offset = 44;
      const channelData = [];
      for (let i = 0; i < numChannels; i++) {
        channelData.push(buffer.getChannelData(i));
      }
      
      let pos = 0;
      for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
          let sample = channelData[channel][i];
          sample = Math.max(-1, Math.min(1, sample));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset + pos, sample, true);
          pos += 2;
        }
      }
      
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // Update Progress
    function updateProgress() {
      const uploaded = PRAYERS.filter(p => prayerStates[p.id]?.uploaded).length;
      document.getElementById('progress-count').textContent = uploaded;
      document.getElementById('progress-bar').style.width = (uploaded / 7 * 100) + '%';
    }

    // Toast Notification
    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <span>${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}</span>
        <span>${message}</span>
      `;
      container.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      }, 4000);
    }
  </script>
</body>
</html>
